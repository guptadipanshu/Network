#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/stat.h>

struct sockaddr_in server;
struct sockaddr_in from;
int fromlen;
FILE *fp;
unsigned long long int ack_size=0;
unsigned long long int ack_nack[9000000];
static int seen=0;
unsigned long long int read_window=0;
unsigned long long int last_window=0;
unsigned long long int current_window;
void reliablyReceive(int *sock_fd,char*filename);
unsigned long long int readData(char *buf,char *filename,unsigned long long int last_ack);
unsigned long long int find_ack(unsigned long long int seq_no, unsigned long long int last_ack);
pthread_mutex_t file_mutex;
int seq_zero_processed=0;
void handler(int sig)
{
	
	exit(0);
}
int main(int argc, char** argv)
{
	int udpPort;
	if(argc != 3)
	{
		//fprintf(stderr, "usage: %s UDP_port filename_to_write\n\n", argv[0]);
		exit(1);
	}
	pthread_mutex_init(&file_mutex,NULL);
	udpPort = atoi(argv[1]);
	fromlen = sizeof( struct sockaddr_in ); 
	int * sock_fd=malloc(sizeof(int));   	
	*sock_fd=socket(AF_INET,SOCK_DGRAM,0);
	// fprintf(stderr,"unable to read ");
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;   /* ok from any machine */
	server.sin_port = htons(udpPort);   
	int yes=1;
	if (setsockopt(*sock_fd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1)
 	{
   		//fprintf(stderr,"Unable to connect maybe Host not found or wrong port\n");
   	} 
	if (bind(*sock_fd,(struct sockaddr *) &server, sizeof(server))) 
	{
	
		//perror("binding udp socket\n");
		exit(1);
	}
	fflush(stderr);
	signal(SIGINT,handler);
	reliablyReceive(sock_fd,argv[2]);
}

void reliablyReceive(int *sock_fd,char* filename)
{
	//memset(ack_nack,0,sizeof(ack_nack));
	char ack[6000];
	fp = fopen(filename, "wb+");
	fclose(fp);
	fp = fopen(filename, "rb+");
	unsigned long long int last_ack=1;
	for ( ;; )
	 {     /* do forever */
		//fprintf(stderr,"Waiting to Read \n");
		int rc;
		char *buf;
		buf=malloc(sizeof(char)*6000);
		memset(buf,'\0',(sizeof(char)*6000));
		if ((rc=recvfrom(*sock_fd, buf, 1000, 0, (struct sockaddr *)&from, &fromlen)) < 0 ) 
		{
			//printf("server error: errno %d\n",errno);
			//perror("reading datagram");
			exit(1);
		}
		else
		{
			
			pthread_mutex_lock(&file_mutex);
			last_ack=readData(buf,filename,last_ack);
			pthread_mutex_unlock(&file_mutex);
			if((read_window>=current_window && seen==1)|| last_ack==0)
			{
<<<<<<< .mine
				read_window=0;
				seen=0;
				memset(ack,'\0',sizeof(ack));
	
				sprintf(ack,"%lld",last_ack);
				//fprintf(stderr,"asking ack %s\n",ack);
				while(sendto(*sock_fd,ack,strlen(ack),0,(struct sockaddr *)&from,sizeof (struct sockaddr_in))==-1)	
				{
				fprintf(stderr,"\nACK NOT SEND ");
				}
				if(last_ack==0)
				{
					fclose(fp);
					exit(0);
				}
				//fprintf(stderr,"\nACK SEND ");	
			}			
=======
				read_window=0;
				seen=0;
				memset(ack,'\0',sizeof(ack));
	
				sprintf(ack,"%lld",last_ack);
				//fprintf(stderr,"asking ack %s\n",ack);
				while(sendto(*sock_fd,ack,strlen(ack),0,(struct sockaddr *)&from,sizeof (struct sockaddr_in))==-1)	
				{
				fprintf(stderr,"\nACK NOT SEND ");
				}
				if(last_ack==0)
				exit(0);
				//fprintf(stderr,"\nACK SEND ");	
			}			
>>>>>>> .r1518
		}
	
	}
}

unsigned long long int readData(char *buf,char *filename,unsigned long long int last_ack)
{
	char seq[1000];
	unsigned long long int seq_no;
	unsigned long long int pack_size;
	unsigned long long int offset_no;
	unsigned long long int window_id;
	char packet_size[1000];
	char offset[900];
	char win_id[900];
	char mssg[3000];//this is the max packet size we will kwwp
	memset(mssg,'\0',sizeof(mssg));
	memset(seq,'\0',sizeof(seq));
	memset(win_id,'\0',sizeof(win_id));
	memset(packet_size,'\0',sizeof(packet_size));
	//fprintf(stderr,"buffer %d ",strlen(buf));
	unsigned long long int i,j,k=0,l=0,m=0,o=0,p=0,v=0,t=0;
	for(i=0;i<3000;i++)
	{
		if(buf[i]!='.')
		{
			seq[i]=buf[i];
			//fprintf(stderr,"%c", ((char *)buf)[i]);
		}
		else
		{	
			//fprintf(stderr,"t ");
			for(j=i+1;j<3000;j++,k++)
			{
				if(buf[j]!='.')
				{
					offset[k]=buf[j];
					//fprintf(stderr,"%c", ((char *)buf)[j]);
				}
				else
				{
					//fprintf(stderr,"%t ");
					for(l=j+1;l<=3000;l++,m++)
					{
						if(buf[l]!='.')
						{
							packet_size[m]=buf[l];	
							//fprintf(stderr,"%c", ((char *)buf)[l]);
						}
						else
						{
							//fprintf(stderr,"%t ");
							pack_size=atoll(packet_size);
							for(o=l+1;o<=3000;o++,p++)
							{	if(buf[o]!=' ')
									win_id[p]=buf[o];
								else
								{
									for(v=o+1;v<=pack_size+o;v++,t++)
										mssg[t]=((char *)buf)[v];
									break;	
								}	
								
							//	fprintf(stderr,"%c", ((char *)buf)[o]);
							}
							break;
						}
					}
					break;	
				}	
		 	}
		 	break;		
		}		
	}
	seq_no=atoll(seq);
	offset_no=atoll(offset);
	window_id=atoll(win_id);
	current_window=window_id;
	if(last_window!=current_window)
	{
		seen=1;
		last_window=current_window;
	}
	//fprintf(stderr,"\n--\n");
	//fprintf(stderr,"seq_no %lld offset %lld packet_size %lld window %lld\n",seq_no,offset_no,pack_size,window_id);
	if(ack_nack[seq_no]==0 && seq_zero_processed!=1)
	{
		if(seq_no==0)
			seq_zero_processed=1;
		//This is the first time we get this packet
		ack_nack[seq_no]=seq_no;//mark processed
		if(seq_no>=ack_size)
			ack_size=seq_no;
		
		//for(i = 0;i < 60;++i)
			//fprintf(stderr,"%c", ((char *)mssg)[i]);
		fseek(fp,offset_no,SEEK_SET);
		fwrite(mssg,1,pack_size,fp);
		//fprintf(stderr,"\n");
		fseek(fp,0,SEEK_END);
		
		read_window++;
		read_window++;
		return find_ack(seq_no,last_ack);
	}
	else
	{
		fprintf(stderr,"DUPLICATE PACKET DETECTED\n");
		return find_ack(seq_no,last_ack);
	}
}
/*This function will return the ack to be send to sender i.e if packet 3 comes before 1 we return ack1 else return ack3*/
unsigned long long int find_ack(unsigned long long int seq_no,unsigned long long int last_ack)
{
	unsigned long long int i;
	if(seq_no==0)//last packet received
		return seq_no;
	//update last_ack which tells this is the last packet i.e 1._._.4-> 1._._.4(last_ack)
	for(i=1;i<ack_size;i++)
	{
		if(ack_nack[i]==0)
			return i;
	}	
	return ack_size+1;
}
